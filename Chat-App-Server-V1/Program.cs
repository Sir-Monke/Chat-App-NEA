/*
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⣀⠀⠀⠀⠀⢶⣦⣄⣀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢀⣤⡴⢀⣠⣴⣶⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣶⣦⣤⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⣀⣀⣀⣤⣴⣶⣶⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣌⡙⠿⣿⣦⣄⡀⠀⠀
⠀⠀⣀⣤⣾⣿⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠺⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣉⠻⣿⣶⠀
⢀⣶⣿⢟⣽⣿⣿⣿⡿⠿⠛⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠛⠛⠛⠿⠿⠿⣿⣿⣿⣿⠿⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠿⢿⣿⣿⡿⠿⠿⠿⠟⠛⠋⠉⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠿⢿⣿⣿⣷⣜⠃⠀
⠀⠙⢡⣿⣿⡿⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⣀⠋⠁⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢈⣁⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⢿⣿⣷⡄
⠀⠀⠈⠛⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⢁⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣈⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠛⠁
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣴⣶⣶⣶⣶⣶⣶⣦⣶⣤⣤⣤⣤⣤⣤⣤⣤⣀⠀⠘⣿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⠋⠁⣠⣤⣤⣶⣶⣶⣶⣶⣶⣾⣿⣿⣾⣿⣿⣿⣿⣶⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣶⣿⡟⠋⠁⣼⣿⣿⣿⣿⣿⡟⢻⣿⣿⡍⣿⣿⣏⠙⠛⠃⠀⢹⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⠉⠀⠀⠉⢁⣼⣿⣿⢁⣿⣿⣿⣿⣿⣿⣿⠛⣿⣿⠤⠉⠛⢻⣿⣷⡄⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⣿⣟⣁⣀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠈⢿⣿⣷⠀⠀⠀⢸⡿⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⠀⠀⠀⣾⣿⠿⠁⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⣀⠀⢀⣿⣿⣿⣦⡄⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠘⠛⠀⠙⠿⣿⣿⣷⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣯⣶⣶⣶⣽⣿⣿⡀⠀⠘⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠛⠀⢀⣼⣿⣷⡶⠶⠶⠿⠿⠿⠿⠿⠿⢿⣿⠿⠷⠶⣿⣿⣿⠿⠋⠀⠙⠃⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⡀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣶⡿⠃⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣾⡟⠁⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⠏⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⠟⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣶⡀⠀⠀⠀⠀⠀⢀⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⡿⠋⠀⠀⠀⠀⠀⣾⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣾⣿⠟⠀⠀⠀⠀⠀⠀⣼⣿⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⣶⣾⡿⠿⠛⠀⠀⠀⠀⠀⠀⠀⢠⣿⡟⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣾⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⣀⣤⣤⣤⣴⣶⣶⣿⣿⣿⠿⠛⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣷⣾⣶⣿⣷⣶⣶⣶⣶⣶⣶⣶⣶⣾⣿⣷⣾⣿⣿⣿⣿⣿⣿⠿⠿⠿⠿⠿⠿⠛⠛⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣭⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠁⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
*/


// thank god for stack overflow bro i would be done for if that shit didnt exist

using System;
using System.Net;
using System.Net.NetworkInformation;
using System.Collections.Generic;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public static class ProtocolConsts
{
    public const byte TypePing = 0x01;
    public const byte TypeData = 0x02;
    public const byte TypeOther = 0x03;

    public const int HeaderSize = 5; // MessageType (1 byte) + PayloadLength (4 bytes)
}

class ServerTCPApp
{
    public static TcpListener Server;

    // to display a few of the Client Messages below menu
    public static List<string> RecentMessages = new List<string>();

    class ServerTCPHandler
    {
        // Server Info
        private static readonly IPAddress LocalAddr = GetServerIPv4();
        private static readonly int Port = 80;
        private static bool ServerState = false;

        //Server Connection Info
        private int ConnectedClients = 0;
        private static readonly int MaxClientConnections = 10;

        // Server Simple Info
        public IPAddress GetServerIp() { return LocalAddr; }
        public int GetServerPort() { return Port; }
        public int GetConnectedClients() { return ConnectedClients; }


        // Server Init
        private static IPAddress GetServerIPv4() // Get Server Addr if cant get local will just get any which is just 0.0.0.0 bit weird why it does tha
        {
            foreach (var ni in NetworkInterface.GetAllNetworkInterfaces())
            {
                if (ni.OperationalStatus == OperationalStatus.Up)
                {
                    foreach (var ip in ni.GetIPProperties().UnicastAddresses)
                    {
                        if (ip.Address.AddressFamily == AddressFamily.InterNetwork && !IPAddress.IsLoopback(ip.Address))
                        {
                            return ip.Address;
                        }
                    }
                }
            }
            return IPAddress.Any;
        }
        public bool InitServer()
        {
            if (Server == null)
            {
                Server = new TcpListener(LocalAddr, Port);
                try
                {
                    ToggleServer();
                    Task.Run(() => HandleClientRequests()); // Run client handling in a separate task
                    return true;
                }
                catch (Exception e)
                {
                    Console.WriteLine("Initialization error: {0}", e.Message);
                    return false;
                }
            }
            return false;
        }
        public void ServerShutDown()
        {
            if (ServerState)
            {
                ToggleServer();
                ConnectedClients = 0;
            }
        }

        private static void ToggleServer()
        {
            ServerState = !ServerState;
            if (ServerState)
            {
                Server.Start();
                Console.WriteLine("Server started, TCP listening on {0}:{1}", LocalAddr, Port);
            }
            else
            {
                try
                {
                    Server.Stop();
                }
                catch (ObjectDisposedException)
                {
                    // do nothing will happen 
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Error stopping server: {0}", ex.Message);
                }
                finally
                {
                    Server = null;
                    Console.WriteLine("Server stopped on {0}:{1}", LocalAddr, Port);
                }
            }
        }

        private async Task HandleClientRequests()
        {
            while (ServerState)
            {
                try
                {
                    var client = await Server.AcceptTcpClientAsync();
                    if (!ServerState) break; // Exit if server is no longer running

                    ConnectedClients++;
                    _ = Task.Run(() => HandleClientAsync(client));
                }
                catch (ObjectDisposedException)
                {
                    break;
                }
                catch (Exception e)
                {
                    Console.WriteLine("Accept error: {0}", e.Message);
                }
            }
        }

        // Handles packets sent to server along with how to deal with them msgs / pings / certain disconects
        private async Task HandleClientAsync(TcpClient client)
        {
            IPAddress clientIP = ((IPEndPoint)client.Client.RemoteEndPoint).Address;
            int clientPort = ((IPEndPoint)client.Client.RemoteEndPoint).Port;

            try
            {
                using (var stream = client.GetStream())
                {
                    while (client.Connected)
                    {
                        // Read header
                        byte[] headerBuffer = new byte[ProtocolConsts.HeaderSize];
                        int headerBytesRead = 0;
                        while (headerBytesRead < headerBuffer.Length)
                        {
                            int bytesRead = await stream.ReadAsync(headerBuffer, headerBytesRead, headerBuffer.Length - headerBytesRead);
                            if (bytesRead == 0) break;
                            headerBytesRead += bytesRead;
                        }

                        if (headerBytesRead < ProtocolConsts.HeaderSize)
                        {
                            break;
                        }

                        byte messageType = headerBuffer[0];
                        int payloadLength = BitConverter.ToInt32(headerBuffer, 1);

                        // Read payload if needed
                        byte[] payload = new byte[payloadLength];
                        int payloadBytesRead = 0;
                        if (payloadLength > 0)
                        {
                            while (payloadBytesRead < payload.Length)
                            {
                                int bytesRead = await stream.ReadAsync(payload, payloadBytesRead, payload.Length - payloadBytesRead);
                                if (bytesRead == 0) break;
                                payloadBytesRead += bytesRead;
                            }

                            if (payloadBytesRead < payloadLength)
                            {
                                Console.WriteLine("Error: Incomplete payload read.");
                                break;
                            }
                        }

                        switch (messageType)
                        {
                            case ProtocolConsts.TypePing:
                                byte[] responseBuffer = new byte[ProtocolConsts.HeaderSize];
                                responseBuffer[0] = ProtocolConsts.TypePing;
                                BitConverter.GetBytes(0).CopyTo(responseBuffer, 1);
                                await stream.WriteAsync(responseBuffer, 0, responseBuffer.Length);
                                break;
                            case ProtocolConsts.TypeData:
                                string data = Encoding.ASCII.GetString(payload);
                                string message = $"Message from {clientIP}:{clientPort}: {data}";

                                lock (RecentMessages)
                                {
                                    if (RecentMessages.Count >= 3)
                                    {
                                        RecentMessages.RemoveAt(0);
                                    }
                                    RecentMessages.Add(message);
                                }
                                Console.WriteLine(message);
                                break;
                            case ProtocolConsts.TypeOther:
                                // Handle other message types if needed
                                break;
                            default:
                                Console.WriteLine($"Unknown message type: {messageType}");
                                break;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Forceful disconnect by client {0}:{1}", clientIP, clientPort);
            }
            finally
            {
                client.Close();
                ConnectedClients--;
                Console.WriteLine("Client {0}:{1} disconnected.", clientIP, clientPort);
            }
        }
    }

    class ServerUI : ServerTCPHandler
    {
        ConsoleKeyInfo key;
        int index = 1; // option currently being selected 
        bool isSelected = false;
        string GreenColour = "\u001b[94m";
        bool bExit = false;

        bool[] toggledOptions = new bool[4];// array to keep track of the toggled stuff in ui

        private void Header()
        {
            Console.WriteLine("Bean Server Console UI - Made By Le Monke");
            Console.WriteLine("Use Arrow Keys to navigate UI and use Enter/Return to select.\n");
        }

        public void Main()
        {
            while (!bExit)
            {
                Console.Clear();

                (int Left, int Top) = Console.GetCursorPosition();
                Console.SetCursorPosition(Left, Top);

                Header();

                // Display options with toggle state and server status
                Console.WriteLine($"{(index == 1 ? GreenColour : "")}Start Server{(toggledOptions[0] ? " \u001b[92mX - Server started on " + GetServerIp() + ":" + GetServerPort()  + " : Connected Clients " + GetConnectedClients(): "")}\u001b[0m");
                Console.WriteLine($"{(index == 2 ? GreenColour : "")}List Clients{(toggledOptions[1] ? " \u001b[92mX" : "")}\u001b[0m");
                Console.WriteLine($"{(index == 3 ? GreenColour : "")}Shutdown Server{(toggledOptions[2] ? " \u001b[92mX" : "")}\u001b[0m");
                Console.WriteLine($"{(index == 4 ? GreenColour : "")}Exit{(toggledOptions[3] ? " \u001b[92mX" : "")}\u001b[0m");

                // Display recent messages
                lock (RecentMessages)
                {
                    foreach (var message in RecentMessages)
                    {
                        Console.WriteLine(message);
                    }
                }

                key = Console.ReadKey(true);

                switch (key.Key)
                {
                    case ConsoleKey.DownArrow:
                        index = (index == 4) ? 1 : index + 1;
                        break;
                    case ConsoleKey.UpArrow:
                        index = (index == 1) ? 4 : index - 1;
                        break;
                    case ConsoleKey.Enter:
                        isSelected = true;
                        HandleSelection();
                        isSelected = false;
                        break;
                }
            }
        }

        private void HandleSelection()
        {
            switch (index)
            {
                case 1:
                    if (!toggledOptions[0])
                    {
                        InitServer();
                        toggledOptions[0] = true;
                        toggledOptions[2] = false;
                    }
                    break;
                case 2:
                    //ListClients(); - not done yet 
                    toggledOptions[1] = !toggledOptions[1];
                    break;
                case 3:
                    if (toggledOptions[0])
                    {
                        ServerShutDown();
                        toggledOptions[2] = true;
                        toggledOptions[0] = false;
                    }
                    break;
                case 4:
                    bExit = true;
                    break;
            }
        }
    }

    private static void Main(string[] args)
    {
        //Console Ui
        ServerUI balls = new ServerUI();

        balls.Main();
    }
}
