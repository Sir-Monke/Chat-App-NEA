/*
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⣀⠀⠀⠀⠀⢶⣦⣄⣀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢀⣤⡴⢀⣠⣴⣶⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣶⣦⣤⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⣀⣀⣀⣤⣴⣶⣶⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣌⡙⠿⣿⣦⣄⡀⠀⠀
⠀⠀⣀⣤⣾⣿⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠺⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣉⠻⣿⣶⠀
⢀⣶⣿⢟⣽⣿⣿⣿⡿⠿⠛⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠛⠛⠛⠿⠿⠿⣿⣿⣿⣿⠿⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠿⢿⣿⣿⡿⠿⠿⠿⠟⠛⠋⠉⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠿⢿⣿⣿⣷⣜⠃⠀
⠀⠙⢡⣿⣿⡿⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⣀⠋⠁⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢈⣁⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⢿⣿⣷⡄
⠀⠀⠈⠛⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⢁⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣈⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠛⠁
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣴⣶⣶⣶⣶⣶⣶⣦⣶⣤⣤⣤⣤⣤⣤⣤⣤⣀⠀⠘⣿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⠋⠁⣠⣤⣤⣶⣶⣶⣶⣶⣶⣾⣿⣿⣾⣿⣿⣿⣿⣶⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣶⣿⡟⠋⠁⣼⣿⣿⣿⣿⣿⡟⢻⣿⣿⡍⣿⣿⣏⠙⠛⠃⠀⢹⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⠉⠀⠀⠉⢁⣼⣿⣿⢁⣿⣿⣿⣿⣿⣿⣿⠛⣿⣿⠤⠉⠛⢻⣿⣷⡄⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⣿⣟⣁⣀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠈⢿⣿⣷⠀⠀⠀⢸⡿⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⠀⠀⠀⣾⣿⠿⠁⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⣀⠀⢀⣿⣿⣿⣦⡄⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠘⠛⠀⠙⠿⣿⣿⣷⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣯⣶⣶⣶⣽⣿⣿⡀⠀⠘⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠛⠀⢀⣼⣿⣷⡶⠶⠶⠿⠿⠿⠿⠿⠿⢿⣿⠿⠷⠶⣿⣿⣿⠿⠋⠀⠙⠃⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⡀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣶⡿⠃⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣾⡟⠁⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⠏⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⠟⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣶⡀⠀⠀⠀⠀⠀⢀⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⡿⠋⠀⠀⠀⠀⠀⣾⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣾⣿⠟⠀⠀⠀⠀⠀⠀⣼⣿⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⣶⣾⡿⠿⠛⠀⠀⠀⠀⠀⠀⠀⢠⣿⡟⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣾⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⣀⣤⣤⣤⣴⣶⣶⣿⣿⣿⠿⠛⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣷⣾⣶⣿⣷⣶⣶⣶⣶⣶⣶⣶⣶⣾⣿⣷⣾⣿⣿⣿⣿⣿⣿⠿⠿⠿⠿⠿⠿⠛⠛⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣭⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠁⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
*/


// thank god for stack overflow bro i would be done for if that shit didnt exist

using System;
using System.Net;
using System.Net.NetworkInformation;
using System.Collections.Generic;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;
using System.Runtime.InteropServices;

using System.Security.Cryptography.X509Certificates;
using System.Net.Security;
using System.Security.Authentication;

public static class ProtocolConsts
{
    public const byte TypePing = 0x01;
    public const byte TypeData = 0x02;
    public const byte TypePrivateGroup = 0x03;
    public const byte TypePrivateManage = 0x04;
    public const byte TypeOther = 0x05; // mainly for client id sending

    public const int HeaderSize = 5; // MessageType (1 byte) + PayloadLength (4 bytes)
}

class ServerTCPApp
{
    public static TcpListener Server;

    // Sexy wexy people who connect to the Server will be placed in the mega volitile dictionary <3
    public static Dictionary<string, Client> Clients = new Dictionary<string, Client>(); // arrrrrr de string shall always beeeee the Client IDDDDDD XOXOXO Slay Ohio Rizzler Skibidi Toilet
    public static Dictionary<string, Group> Groups = new Dictionary<string, Group>(); // not sure how this will.. gonna use the group obj along with the groups id

    // to display a few of the Client Messages below menu
    public static List<string> RecentMessages = new List<string>();

    public class Client
    {

        public Client()
        {
            ClientId = GenClientId();
        }

        public IPAddress IPAddress { get; set; }
        public int Port { get; set; }
        public TcpClient TcpClientAsync { get; set; }
        public string ClientId { get; private set; }
        public static List<string> ActiveGroups = new List<string>();


        //Client ID Stuff Shenanigans - not sure how it gonna go having this here - should be fine
        private static readonly char[] chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".ToCharArray();
        private static Random random = new Random();
        private static readonly object lockObj = new object();

        private static string GenClientId()
        {
            char[] id = new char[6]; // 6 chars of length spittin bars in cars.
            lock (lockObj) // ladies ladies please.. one thread at a time B)
            {
                for (int i = 0; i < id.Length; i++)
                {
                    id[i] = chars[random.Next(chars.Length)];
                }
            }
            return new string(id, 0, 3) + "-" + new string(id, 3, 3); // total client id len should be 7 bytes always
        }
    }

    public class Group
    {
        public string GroupId { get; private set; }
        public string GroupName { get; set; }
        private List<Client> Members { get; set; } = new List<Client>();

        private static readonly char[] chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#%&*".ToCharArray();
        private static readonly object lockObj = new object();
        private static Random random = new Random();

        public Group(string groupName)
        {
            GroupName = groupName;
            GroupId = GenGroupId();
        }

        public bool AddMember(string clientId)
        {
            lock (lockObj) // just gonna use lock as i like using it and it seams cool
            {
                if (Members.Any(c => c.ClientId == clientId))
                {
                    return false; // some mong trying to add a client thats already in this bitch
                }

                if (Clients.TryGetValue(clientId, out Client client))
                {
                    Members.Add(client); // thank fuck 
                    return true;
                }
                else
                {
                    return false; // null client. the retard cant type a fucking 7 digit id 
                }
            }
        }

        public bool RemoveMember(string clientId)
        {
            lock (lockObj) // just gonna use lock as i like using it and it seams cool
            {
                Client existingClient = Members.SingleOrDefault(c => c.ClientId == clientId);
                if (existingClient != null)
                {
                    Members.Remove(existingClient);
                    return true;
                }
                return false;
            }
        }

        public void BroadcastMessage(string message, string senderClientId) // send message to all group members
        {
            lock (Members)
            {
                foreach (Client client in Members)
                {
                    if (client.ClientId != senderClientId)
                    {
                        //SendMessageToClient(client, ProtocolConsts.TypePrivateGroup, message);
                    }
                }
            }
        }

        private static string GenGroupId()
        {
            char[] id = new char[15];
            lock (lockObj)
            {
                for (int i = 0; i < id.Length; i++)
                {
                    id[i] = chars[random.Next(chars.Length)];
                }
            }

            // Convert char array to string and insert dashes
            string idString = new string(id);
            for (int i = 5; i < idString.Length; i += 6)
            {
                idString = idString.Insert(i, "-");
            }

            return idString; // Should be something like XXXXX-XXXXX-XXXXX
        }


        private void SendMessageToClient(Client client, byte messageType, string message)
        {
            byte[] messagePayload = Encoding.ASCII.GetBytes(message);
            byte[] messageBuffer = new byte[ProtocolConsts.HeaderSize + messagePayload.Length];

            messageBuffer[0] = messageType;
            BitConverter.GetBytes(messagePayload.Length).CopyTo(messageBuffer, 1);
            messagePayload.CopyTo(messageBuffer, ProtocolConsts.HeaderSize);

            NetworkStream stream = client.TcpClientAsync.GetStream();
            stream.Write(messageBuffer, 0, messageBuffer.Length);
        }
    }

    public class ServerTCPHandler
    {
        // Server Info
        private static readonly IPAddress LocalAddr = GetServerIPv4();
        private static readonly int Port = 80; // Tcp Server port will always be 80 - unless U CHANGE IT.....
        private static bool ServerState = false;

        //Server Connection Info
        private int ConnectedClients = 0;
        private static readonly int MaxClientConnections = 10;

        // Server Simple Info
        public IPAddress GetServerIp() { return LocalAddr; }
        public int GetServerPort() { return Port; }
        public int GetConnectedClients() { return ConnectedClients; }


        // Server Init
        private static IPAddress GetServerIPv4() // Get Server Addr if cant get local will just get any which is just 0.0.0.0 bit weird why it does tha
        {
            foreach (var ni in NetworkInterface.GetAllNetworkInterfaces())
            {
                if (ni.OperationalStatus == OperationalStatus.Up)
                {
                    foreach (var ip in ni.GetIPProperties().UnicastAddresses)
                    {
                        if (ip.Address.AddressFamily == AddressFamily.InterNetwork && !IPAddress.IsLoopback(ip.Address))
                        {
                            return ip.Address;
                        }
                    }
                }
            }
            return IPAddress.Any;
        }
        public bool InitServer()
        {
            if (Server == null)
            {
                Server = new TcpListener(LocalAddr, Port);
                try
                {
                    ToggleServer();
                    Task.Run(() => HandleClientRequests()); // Run client handling in a separate task
                    return true;
                }
                catch (Exception e)
                {
                    Console.WriteLine("Initialization error: {0}", e.Message);
                    return false;
                }
            }
            return false;
        }
        public void ServerShutDown()
        {
            if (ServerState)
            {
                ToggleServer();
                ConnectedClients = 0;
            }
        }
        private static void ToggleServer()
        {
            ServerState = !ServerState;
            if (ServerState)
            {
                Server.Start();
            }
            else
            {
                try
                {
                    Server.Stop();
                }
                catch (ObjectDisposedException)
                {
                    // nothing will happen... i think
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Error stopping server: {0}", ex.Message);
                }
                finally
                {
                    Server = null;
                    Console.WriteLine("Server stopped on {0}:{1}", LocalAddr, Port);
                }
            }
        }
        public async Task AssignClientId(Client client) // not the best way of doing this but for sure better than the client creating this Id might try GUIDs for this or group chat Ids
        {
            byte[] idPayload = Encoding.ASCII.GetBytes(client.ClientId);
            byte[] ipPayload = Encoding.ASCII.GetBytes(client.IPAddress.ToString());
            byte[] portPayload = BitConverter.GetBytes(client.Port);

            int payloadLength = idPayload.Length + ipPayload.Length + portPayload.Length;
            byte[] messageBuffer = new byte[ProtocolConsts.HeaderSize + payloadLength];

            // Set the message type
            messageBuffer[0] = ProtocolConsts.TypeOther;

            // Set the payload length
            BitConverter.GetBytes(payloadLength).CopyTo(messageBuffer, 1);

            // Copy the unique ID
            idPayload.CopyTo(messageBuffer, ProtocolConsts.HeaderSize);

            // Copy the IP address
            int offset = ProtocolConsts.HeaderSize + idPayload.Length;
            ipPayload.CopyTo(messageBuffer, offset);

            // Copy the port
            offset += ipPayload.Length;
            portPayload.CopyTo(messageBuffer, offset);

            NetworkStream stream = client.TcpClientAsync.GetStream();
            await stream.WriteAsync(messageBuffer, 0, messageBuffer.Length);
        }

        // Client Connection Reqs
        private async Task HandleClientRequests()
        {
            while (ServerState)
            {
                try
                {
                    TcpClient clientTCP = await Server.AcceptTcpClientAsync();
                    IPEndPoint clientEndpoint = (IPEndPoint)clientTCP.Client.RemoteEndPoint;
                    Client clientObj = new Client { IPAddress = clientEndpoint.Address, Port = clientEndpoint.Port, TcpClientAsync = clientTCP };
                    await AssignClientId(clientObj);
                    Clients[clientObj.ClientId] = clientObj; ConnectedClients++;


                    _ = Task.Run(() => HandleClientAsync(clientObj));
                }
                catch (ObjectDisposedException)
                {
                    break;
                }
                catch (Exception e)
                {
                    Console.WriteLine("Accept error: {0}", e.Message);
                }
            }
        }

        // Handles packets sent to server along with how to deal with them msgs / pings / certain disconects / info stuff
        private async Task HandleClientAsync(Client ClientObj)
        {
            TcpClient tempClientAsync = ClientObj.TcpClientAsync;

            IPAddress clientIP = ((IPEndPoint)tempClientAsync.Client.RemoteEndPoint).Address;
            int clientPort = ((IPEndPoint)tempClientAsync.Client.RemoteEndPoint).Port;

            try
            {
                using (NetworkStream stream = tempClientAsync.GetStream())
                {
                    while (tempClientAsync.Connected)
                    {
                        // Read header
                        byte[] headerBuffer = new byte[ProtocolConsts.HeaderSize];
                        int headerBytesRead = 0;
                        while (headerBytesRead < headerBuffer.Length)
                        {
                            int bytesRead = await stream.ReadAsync(headerBuffer, headerBytesRead, headerBuffer.Length - headerBytesRead);
                            if (bytesRead == 0) break;
                            headerBytesRead += bytesRead;
                        }

                        if (headerBytesRead < ProtocolConsts.HeaderSize)
                        {
                            break;
                        }

                        byte messageType = headerBuffer[0];
                        int payloadLength = BitConverter.ToInt32(headerBuffer, 1);

                        // Read payload if needed
                        byte[] payload = new byte[payloadLength];
                        int payloadBytesRead = 0;
                        if (payloadLength > 0)
                        {
                            while (payloadBytesRead < payload.Length)
                            {
                                int bytesRead = await stream.ReadAsync(payload, payloadBytesRead, payload.Length - payloadBytesRead);
                                if (bytesRead == 0) break;
                                payloadBytesRead += bytesRead;
                            }

                            if (payloadBytesRead < payloadLength)
                            {
                                Console.WriteLine("Error: Incomplete payload read.");
                                break;
                            }
                        }

                        string data = Encoding.ASCII.GetString(payload);
                        string message;

                        switch (messageType)
                        {
                            case ProtocolConsts.TypePing:
                                byte[] responseBuffer = new byte[ProtocolConsts.HeaderSize];
                                responseBuffer[0] = ProtocolConsts.TypePing;
                                BitConverter.GetBytes(0).CopyTo(responseBuffer, 1);
                                await stream.WriteAsync(responseBuffer, 0, responseBuffer.Length);
                                break;
                            case ProtocolConsts.TypeData: // used to be used for general messages but no need for that now
                                message = $"Message from {ClientObj.IPAddress}:{ClientObj.Port}: {data}";

                                lock (RecentMessages) // not even gonna say it.. u know what im gonna say
                                {
                                    RecentMessages.Add(message);
                                    if (RecentMessages.Count > 3)
                                    {
                                        RecentMessages.RemoveAt(0);
                                    }
                                }
                                Console.WriteLine(message);
                                break;
                            case ProtocolConsts.TypePrivateGroup: // group chat messages   payload = (ClientId + " " + groupId + " " + message)
                                if (payloadLength >= 24) // includes the groupid - 17 and client id - 7
                                {
                                    string senderClientId = Encoding.ASCII.GetString(payload, 0, 7); // Extract the first 7 bytes as client ID
                                    string groupId = Encoding.ASCII.GetString(payload, 8, 17); // Extract the next 17 bytes as group ID
                                    message = Encoding.ASCII.GetString(payload, 24, payload.Length - 25); // Extract the rest as the message

                                    Console.WriteLine($"Group Message from {senderClientId} in group {groupId}: {message}");
                                }
                                else
                                {
                                    Console.WriteLine("Payload too short.");
                                }
                                break;
                            case ProtocolConsts.TypePrivateManage: // only for group chats so users can leave join etc
                                break;
                            case ProtocolConsts.TypeOther:
                                // Handle other message types if needed
                                break;
                            default:
                                Console.WriteLine($"Unknown message type: {messageType}");
                                break;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Forceful disconnect by client {0}:{1}", ClientObj.IPAddress, ClientObj.Port);
            }
            finally
            {
                tempClientAsync.Close();
                Clients.Remove(ClientObj.ClientId);
                ConnectedClients--;
                Console.WriteLine("Client {0}:{1} disconnected.", ClientObj.IPAddress, ClientObj.Port);
            }
        }
    }

    class ServerUI : ServerTCPHandler
    {
        ConsoleKeyInfo key;
        int index = 1; // option currently being selected 
        bool isSelected = false;
        string GreenColour = "\u001b[94m";
        bool bExit = false;

        bool[] toggledOptions = new bool[4];// array to keep track of the toggled stuff in ui

        private void Header()
        {
            Console.WriteLine("Bean Server Console UI - Made By Le Monke");
            Console.WriteLine("Use Arrow Keys to navigate UI and use Enter/Return to select.\n");
        }

        public void Main()
        {
            while (!bExit)
            {
                Console.Clear();

                (int Left, int Top) = Console.GetCursorPosition();
                Console.SetCursorPosition(Left, Top);

                Header();

                // Display options with toggle state and server status
                Console.WriteLine($"{(index == 1 ? GreenColour : "")}Start Server{(toggledOptions[0] ? " \u001b[92mX - Server started on " + GetServerIp() + ":" + GetServerPort() + " : Connected Clients " + GetConnectedClients() : "")}\u001b[0m");
                Console.WriteLine($"{(index == 2 ? GreenColour : "")}List Clients{(toggledOptions[1] ? " \u001b[92mX" : "")}\u001b[0m");
                Console.WriteLine($"{(index == 3 ? GreenColour : "")}Shutdown Server{(toggledOptions[2] ? " \u001b[92mX" : "")}\u001b[0m");
                Console.WriteLine($"{(index == 4 ? GreenColour : "")}Exit{(toggledOptions[3] ? " \u001b[92mX" : "")}\u001b[0m");

                // Display recent messages
                lock (RecentMessages)// LADIES LADIES ONE AT A TIME - this will never get old
                {
                    foreach (var message in RecentMessages)
                    {
                        Console.WriteLine(message);
                    }
                }

                key = Console.ReadKey(true);

                switch (key.Key)
                {
                    case ConsoleKey.DownArrow:
                        index = (index == 4) ? 1 : index + 1;
                        break;
                    case ConsoleKey.UpArrow:
                        index = (index == 1) ? 4 : index - 1;
                        break;
                    case ConsoleKey.Enter:
                        isSelected = true;
                        HandleSelection();
                        isSelected = false;
                        break;
                }
            }
        }

        private void HandleSelection()
        {
            switch (index)
            {
                case 1:
                    if (!toggledOptions[0])
                    {
                        InitServer();
                        toggledOptions[0] = true;
                        toggledOptions[2] = false;
                    }
                    break;
                case 2:
                    ListClients();
                    break;
                case 3:
                    if (toggledOptions[0])
                    {
                        ServerShutDown();
                        toggledOptions[2] = true;
                        toggledOptions[0] = false;
                    }
                    break;
                case 4:
                    bExit = true;
                    break;
            }
        }

        private void ListClients()
        {
            Console.Clear();
            Header();
            Console.WriteLine("Connected Clients:");

            lock (Clients) // once again ladies ladies one at a time B)
            {
                foreach (var client in Clients.Values)
                {
                    Console.WriteLine($"Client ID: {client.ClientId}, IP: {client.IPAddress}, Port: {client.Port}");
                }
            }
            Console.ReadKey(true);
        }
    }

    private static void Main(string[] args)
    {
        //Console Ui
        ServerUI balls = new ServerUI();

        balls.Main();
    }
}
